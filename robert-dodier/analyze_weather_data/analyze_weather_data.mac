load ("operatingsystem");

if (input: getenv ("INPUT")) = false
    then error ("analyze_weather_data.mac: environment variable INPUT not specified, with no default.");

data: read_matrix (input) $

columns: map (parse_string, data[1]);

columns :: args (transpose (rest (data))) $

/* Maxima timedate doodads are Common Lisp universal times,
 * which cannot be before 1900; a frankly ridiculous limitation.
 * Load the local-time library and redefine parse_timedate to compensate.
 * Would be a good idea to consider moving this into Maxima proper.
 */

load ("timedate-from-local-time.lisp");

DATE_timedate: map (parse_timedate, DATE);

AWND_numeric: map (lambda ([x], if stringp (x) then parse_string (x) else x), AWND);
PRCP_numeric: map (lambda ([x], if stringp (x) then parse_string (x) else x), PRCP);
SNOW_numeric: map (lambda ([x], if stringp (x) then parse_string (x) else x), SNOW);
TMAX_numeric: map (lambda ([x], if stringp (x) then parse_string (x) else x), TMAX);
TMIN_numeric: map (lambda ([x], if stringp (x) then parse_string (x) else x), TMIN);

unique_stations: unique (STATION);

for i thru length (STATION) do names_by_station[STATION[i]]: NAME[i];

for u in unique_stations do printf (true, "~s --> ~s~%", u, names_by_station[u]);

push ("/home/dodier/github/github-forks/maxima-packages/robert-dodier/**/*.mac", file_search_maxima);
push ("/home/dodier/github/github-forks/maxima-packages/robert-dodier/**/*.lisp", file_search_lisp);

load ("json_tools");

defstruct (station_data (DATE, AWND, PRCP, SNOW, TMAX, TMIN));

for u in unique_stations
    do block ([ii: sublist_indices (STATION, lambda ([x], x = u)),
               d: new (station_data)],
              d@DATE: makelist (DATE_timedate[i], i, ii),
              d@AWND: makelist (AWND_numeric[i], i, ii),
              d@PRCP: makelist (PRCP_numeric[i], i, ii),
              d@SNOW: makelist (SNOW_numeric[i], i, ii),
              d@TMAX: makelist (TMAX_numeric[i], i, ii),
              d@TMIN: makelist (TMIN_numeric[i], i, ii),
              data_by_station[u]: d);

winter_year (t) :=
    block ([t_decoded: decode_time (t)],
           if t_decoded[6] >= 7 then t_decoded[7] else t_decoded[7] - 1);

group_by_winter_years (S) :=
    block ([w: map (winter_year, data_by_station[S]@DATE), u],
           u: unique (w),
           makelist (y1 = sublist_indices (w, lambda ([x], x = y1)), y1, u));

tmin_by_winter_years (S) :=
    block ([ii: group_by_winter_years (S), u],
           makelist (lhs (e) = lmin (makelist (data_by_station[S]@TMIN[i], i, rhs (e))), e, ii));

year (t) :=
    block ([t_decoded: decode_time (t)],
           t_decoded[7]);

group_by_years (S) :=
    block ([w: map (year, data_by_station[S]@DATE), u],
           u: unique (w),
           makelist (y1 = sublist_indices (w, lambda ([x], x = y1)), y1, u));

tmax_by_years (S) :=
    block ([ii: group_by_years (S), u],
           makelist (lhs (e) = lmax (makelist (data_by_station[S]@TMAX[i], i, rhs (e))), e, ii));

ymd_regex: regex_compile ("^\\s*(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)\\s*$");

meteo_year_from_string (ymd) :=
    block ([m: regex_match (ymd_regex, ymd)],
           if m # false
               then block ([yy: parse_string (m[2]), mm: parse_string (m[3])],
                           if mm >= 9 then yy else yy - 1));
